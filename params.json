{
  "name": "Libclist",
  "tagline": "libclist is a shared/static library for the c programming language with list and dictionary implementations",
  "body": "<p>\r\n    <a href=\"https://github.com/jpaffrath/libclist\">\r\n        <img src=\"https://img.shields.io/badge/memcheck-passed-orange.svg\"\r\n             alt=\"Memcheck Badge\">\r\n    </a>\r\n    <a href=\"https://github.com/jpaffrath/libclist/tree/master/test\">\r\n        <img src=\"https://img.shields.io/badge/test-passed-green.svg\"\r\n             alt=\"Test Badge\">\r\n    </a>\r\n     <a href=\"https://github.com/jpaffrath/libclist/blob/master/LICENSE\">\r\n        <img src=\"https://img.shields.io/badge/license-MIT-blue.svg\"\r\n             alt=\"License Badge\">\r\n    </a>\r\n</p>\r\n\r\n# Introduction #\r\nlibclist is a shared/static library for the c programming language with list and dictionary implementations.\r\nlibclist is very fast, yet memory saving and customizable. It is able to store any kind of data you like!\r\n\r\n## Compile ##\r\nInvoke *make* in the project root. This will build libclist as a shared (libclist.so) and as a static (libclist.a) library.\r\n\r\n## Install ##\r\nInvoke *sudo make install* in the project root. This will install the required header files along with the library to /usr/local/.\r\n\r\n## Testing ##\r\nThe test/ directory contains unit tests build with CUnit.\r\nInvoke *make* in the test/ directory will build a test binary.\r\nTo check code coverage with gcov, run *gcov_setup.sh*.\r\n\r\n# List API #\r\nProvides a generic interface for a very fast linked list data structure. libclist supports storing any kind of data.\r\nJust\r\n```c\r\n#include <libclist/list.h>\r\n```\r\nin your project and off you go!\r\nWant a simple example? Take this:\r\n```c\r\nint myVal = 5;\r\n\r\n// creates a new list holding your integer variable\r\nelement* list = create_list(&myVal, sizeof(int));\r\n\r\n// adds an elements to your list\r\nadd_element(list, &myVal, sizeof(int));\r\n\r\n// gets an element. You have to cast the result\r\nint result = *(int*)get_element_at_index(list, 1);\r\n```\r\nApart from the generic list interface, libclist provides a data type specialized API\r\n```c\r\n#include <libclist/list_int.h>\r\n#include <libclist/list_char.h>\r\n```\r\nso you can use easier functions:\r\n```c\r\nelement* myIntegerList = create_int_list(100);\r\n\r\nprintf(\"My list contains %d at index %d!\", get_int_at_index(myIntegerList, 0), 0);\r\n```\r\nIf you are done using your list, do not forget to delete it!\r\n```c\r\ndelete_list(&list);\r\n```\r\n\r\n## A special case: structs with pointers! ##\r\nIf you want to store structs with allocated pointers, libclist provides specialized _create_ and _delete_ functions:\r\n```c\r\ntest_struct myStruct;\r\nmyStruct.str = (char*)malloc(100);\r\n\r\nelement* list = create_list_alloc(&ptr, alloc_callback);\r\ndelete_list_alloc(&list, free_callback);\r\n```\r\nThese functions are taking function pointers for allocating and freeing pointers in your struct.\r\nYou just have to define these functions by yourself.\r\nSee the following code for an easy example:\r\n```c\r\nstatic void* alloc_callback(const void* e) {\r\n\ttest_struct* s = (test_struct*)e;\r\n\ttest_struct* copy = (test_struct*)malloc(sizeof(test_struct));\r\n\tnew->str = (char*)malloc(100);\r\n\tstrcpy(copy->str, s->str);\r\n\treturn copy;\r\n}\r\n\r\nstatic void free_callback(const void* e) {\r\n\ttest_struct* ptr = (test_struct*)e;\r\n\tfree(ptr->str);\r\n}\r\n```\r\nList supports a lot of useful functions, just like removing or swapping elements, removing elements in a range, creating list from arrays or strings, or cloning lists. See list.h for all implemented functions.\r\n",
  "note": "Don't delete this file! It's used internally to help with page regeneration."
}